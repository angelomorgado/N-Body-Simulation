#version 460 core

layout (local_size_x = 64) in;

layout(std430, binding = 0) buffer _vertexPosition {
    vec3 vertexPosition[];
};
layout(std430, binding = 1) buffer _vertexSize{
    float vertexSize[];
};
layout(std430, binding = 2) buffer _vertexRadius{
    float vertexRadius[];
};
layout(binding = 3, std430) buffer _vertexColor{
    vec4 vertexColor[];
};
layout(std430, binding = 4) buffer _vertexVelocity{
    vec3 vertexVelocity[];
};
layout(std430, binding = 5) buffer _vertexMass{
    float vertexMass[];
};

// Uniforms
uniform float deltaTime;

// Constants
const float G = 6.67408e-11;

// Functions
vec3 getGravitationalForce(vec3 r, float d, float m1, float m2)
{
    r = normalize(r);
    // float d = length(r);

    // Calculate the gravitational force
    vec3 Gforce = vec3(0.0, 0.0, 0.0);

    Gforce.x = -G * m1 * m2 / (d * d) * r.x;
    Gforce.y = -G * m1 * m2 / (d * d) * r.y;
    Gforce.z = -G * m1 * m2 / (d * d) * r.z;

    return Gforce;
}

void main()
{ 
    uint id = gl_GlobalInvocationID.x;
    
    vec3 Fe = vec3(0.0, 0.0, 0.0);

    for(int i = 0; i < vertexPosition.length(); i++)
    {
        if (id == i)
        {
            continue;
        }
        // Get the distance between the two particles using euclidean distance
        vec3 r = vertexPosition[i] - vertexPosition[id];
        float d = sqrt(r.x * r.x + r.y * r.y + r.z * r.z);

        vec3 Gforce = getGravitationalForce(r, d, vertexMass[i], vertexMass[id]);

        // Calculate the gravitational force
        Fe += Gforce;
    }


    vec3 a = Fe / vertexMass[id];

    // Calculate the new velocity
    vertexVelocity[id] += a * deltaTime;

    // Calculate the new position
    vertexPosition[id] += vertexVelocity[id] * deltaTime / 100.0;
}