#version 460 core

layout (local_size_x = 64) in;

layout(std430, binding = 0) buffer _vertexPosition {
    vec4 vertexPosition[];
};
layout(std430, binding = 1) buffer _vertexSize{
    float vertexSize[];
};
layout(std430, binding = 2) buffer _vertexRadius{
    float vertexRadius[];
};
layout(binding = 3, std430) buffer _vertexColor{
    vec4 vertexColor[];
};
layout(std430, binding = 4) buffer _vertexVelocity{
    vec4 vertexVelocity[];
};
layout(std430, binding = 5) buffer _vertexMass{
    float vertexMass[];
};

// Uniforms
uniform float deltaTime;

// Constants
const float G = 6.67408e-11;

// Functions
vec4 getGravitationalForce(vec4 r, float d, float m1, float m2)
{
    r = normalize(r);
    // float d = length(r);

    // Calculate the gravitational force
    vec4 Gforce = vec4(0.0, 0.0, 0.0, 0.0);

    Gforce.x = -G * m1 * m2 / (d * d) * r.x;
    Gforce.y = -G * m1 * m2 / (d * d) * r.y;
    Gforce.z = -G * m1 * m2 / (d * d) * r.z;

    return Gforce;
}

void main()
{ 
    uint id = gl_GlobalInvocationID.x;
    
    vec4 Fe = vec4(0.0, 0.0, 0.0, 0.0);

    for(int i = 0; i < vertexPosition.length(); i++)
    {
        if (id == i)
        {
            continue;
        }

        vec4 r = vertexPosition[i] - vertexPosition[id];

        float d = length(r);

        vec4 Gforce = getGravitationalForce(r, d, vertexMass[i], vertexMass[id]);

        // Calculate the gravitational force
        Fe += Gforce;
    }

    vec4 a = Fe / vertexMass[id];

    // Calculate the new velocity
    vertexVelocity[id] += a * deltaTime;

    // Calculate the new position
    vertexPosition[id] += vertexVelocity[id] * deltaTime / 10.0;
}