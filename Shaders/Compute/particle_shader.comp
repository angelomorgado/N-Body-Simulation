#version 460 core

layout (local_size_x = 64) in;

layout(std430, binding = 0) buffer _vertexPosition {
    vec4 vertexPosition[];
};
layout(std430, binding = 1) buffer _vertexSize{
    float vertexSize[];
};
layout(std430, binding = 2) buffer _vertexRadius{
    float vertexRadius[];
};
layout(binding = 3, std430) buffer _vertexColor{
    vec4 vertexColor[];
};
layout(std430, binding = 4) buffer _vertexVelocity{
    vec4 vertexVelocity[];
};
layout(std430, binding = 5) buffer _vertexMass{
    float vertexMass[];
};

// Uniforms
uniform float deltaTime;

// Constants
const float G = 6.67408e-11;

// Functions
vec4 getGravitationalForce(vec4 r, float m1, float m2)
{
    float d = length(r);
    r = normalize(r);

    // Calculate the gravitational force
    vec4 Gforce = G * m1 * m2 / (d * d) * r;

    return Gforce;
}

float random(vec2 st)
{
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

void main()
{ 
    uint id = gl_GlobalInvocationID.x;
    
    vec4 Fe = vec4(0.0);
    vec4 velocity = vec4(0.0);

    for(int i = 0; i < vertexPosition.length(); i++)
    {
        if (id == i)
        {
            continue;
        }
        
        vec4 r = vertexPosition[i] - vertexPosition[id];

        vec4 Gforce = getGravitationalForce(r, vertexMass[i], vertexMass[id]);

        // Calculate the gravitational force
        Fe += Gforce;
    }   

    // Calculate the new velocity
    velocity += Fe / vertexMass[id] * deltaTime * 10e5;

    // Calculate the new position
    vertexPosition[id] += velocity;
}