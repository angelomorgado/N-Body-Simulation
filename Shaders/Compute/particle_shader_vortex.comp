#version 460 core

layout (local_size_x = 64) in;

layout(std430, binding = 0) buffer _vertexPosition {
    vec3 vertexPosition[];
};
layout(std430, binding = 1) buffer _vertexSize{
    float vertexSize[];
};
layout(std430, binding = 2) buffer _vertexRadius{
    float vertexRadius[];
};
layout(binding = 3, std430) buffer _vertexColor{
    vec4 vertexColor[];
};
layout(std430, binding = 4) buffer _vertexVelocity{
    vec3 vertexVelocity[];
};
layout(std430, binding = 5) buffer _vertexMass{
    float vertexMass[];
};

// Uniforms
uniform float deltaTime;

// Functions
vec3 vortex_force_function(uint id)
{
    vec3 vortex_position = vec3(0.0f,0.0f,0.0f);
    vec3 force = vortex_position - vertexPosition[id];
    float distance = length(force);
    force /= distance;
    return force;
}

vec3 black_hole(uint id, vec3 black_hole_position)
{
    float gravity = 10.0;
    vec3 dist = black_hole_position - vertexPosition[id];
    vec3 black_hole_force = (gravity / length(dist)) * normalize(dist);

    return black_hole_force;
}

void main()
{ 
    uint id = gl_GlobalInvocationID.x;
    // change the color of the particle to a random color
    vertexColor[id] = vec4(sin(vertexPosition[id].x), cos(vertexPosition[id].y), sin(vertexPosition[id].z), 1.0);

    vec3 force = vortex_force_function(id);
    /*vec3 force = vortex_force_function(id);
    float vortex_strength = 2.0;
    vertexVelocity[id].z += force.z * vortex_strength * deltaTime;
    vertexPosition[id].z += vertexVelocity[id].z * deltaTime;
    vertexPosition[id].z += vertexVelocity[id].z * deltaTime;*/

    vec3 black_hole_force = black_hole(id,vec3(0.0f,0.0f,0.0f));
    vec3 acceleration = black_hole_force * vertexMass[id]/0.1; 

    vertexPosition[id] = vec3(vertexPosition[id] + vertexVelocity[id] * 0.0005 + 0.5 * acceleration * 0.0005 * 0.0005);
    vertexVelocity[id] = vec3(vertexVelocity[id] + acceleration * 0.0005);
}